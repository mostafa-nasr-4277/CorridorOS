name: CorridorOS Stable Deployment

on:
  push:
    branches: [ main ]
  workflow_dispatch:

permissions:
  contents: read
  pages: write
  id-token: write

concurrency:
  group: "pages"
  cancel-in-progress: false

jobs:
  build:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
        
      - name: Clean problematic files and directories
        run: |
          set -euo pipefail
          
          echo "🧹 Cleaning workspace..."
          
          # Remove any files/dirs with problematic characters
          find . -name "*WARNING*" -type f -delete 2>/dev/null || true
          find . -name "*INFO*" -type f -delete 2>/dev/null || true
          find . -name "*SUCCESS*" -type f -delete 2>/dev/null || true
          find . -name "*WARNING*" -type d -exec rm -rf {} + 2>/dev/null || true
          find . -name "*INFO*" -type d -exec rm -rf {} + 2>/dev/null || true
          find . -name "*SUCCESS*" -type d -exec rm -rf {} + 2>/dev/null || true
          
          # Remove hidden problematic files
          find . -name ".*WARNING*" -delete 2>/dev/null || true
          find . -name ".*INFO*" -delete 2>/dev/null || true
          find . -name ".*SUCCESS*" -delete 2>/dev/null || true
          
          # Clean up any remaining problematic paths
          python3 << 'EOF' || true
          import os
          import shutil
          import glob
          
          # Clean up any remaining problematic entries
          for root, dirs, files in os.walk('.'):
              for d in dirs[:]:  # Use slice to modify during iteration
                  if any(x in d for x in ['[WARNING]', '[INFO]', '[SUCCESS]', '\033']):
                      try:
                          shutil.rmtree(os.path.join(root, d))
                          dirs.remove(d)
                      except:
                          pass
              for f in files:
                  if any(x in f for x in ['[WARNING]', '[INFO]', '[SUCCESS]', '\033']):
                      try:
                          os.remove(os.path.join(root, f))
                      except:
                          pass
          EOF
          
          echo "✅ Cleanup complete"
        
      - name: Create curated deployment package
        run: |
          set -euo pipefail
          
          echo "📦 Creating curated deployment package..."
          
          DEPLOY_DIR="deploy_artifact"
          rm -rf "$DEPLOY_DIR"
          mkdir "$DEPLOY_DIR"
          
          RSYNC_EXCLUDES=(
            ".git"
            ".github"
            ".gocache"
            ".gomodcache"
            ".daemon"
            "node_modules"
            "*.tar.gz"
            "*.zip"
            "*.dmg"
            "*.iso"
            "*.img"
            "*.bin"
          )
          
          RSYNC_CMD=(rsync -a --delete)
          for pattern in "${RSYNC_EXCLUDES[@]}"; do
            RSYNC_CMD+=(--exclude "$pattern")
          done
          RSYNC_CMD+=(./ "$DEPLOY_DIR")
          "${RSYNC_CMD[@]}"
          
          # Verify critical files exist
          if [ ! -f "$DEPLOY_DIR/index.html" ]; then
            echo "❌ Critical file index.html missing!"
            exit 1
          fi
          
          # Ensure .nojekyll exists within deployment package
          touch "$DEPLOY_DIR/.nojekyll"
          
          # Count files to deploy
          FILE_COUNT=$(find "$DEPLOY_DIR" -type f | wc -l)
          echo "📊 Deploying $FILE_COUNT files after curation"
          
          echo "✅ Deployment package ready"
        
      - name: Verify deployment package
        run: |
          echo "📋 Contents of deploy_artifact:"
          ls -la deploy_artifact/
          echo "📊 File count in deploy_artifact:"
          find deploy_artifact -type f | wc -l
          echo "🔍 Checking for problematic files:"
          find deploy_artifact -name "*WARNING*" -o -name "*INFO*" -o -name "*SUCCESS*" || echo "✅ No problematic files found"
        
      - name: Upload Pages artifact
        uses: actions/upload-pages-artifact@v4
        with:
          path: deploy_artifact
          
  deploy:
    needs: build
    runs-on: ubuntu-latest
    timeout-minutes: 10
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    steps:
      - name: Deploy to GitHub Pages
        id: deployment
        uses: actions/deploy-pages@v4
